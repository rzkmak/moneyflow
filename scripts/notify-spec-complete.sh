#!/bin/bash

# Script to notify Claude about completed Spec-kit specifications
# Follows the documentation synchronization process

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
SPEC_DIR="specs"
CONSTITUTION_FILE=".specify/memory/constitution.md"

# Helper functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if we're on a feature branch
check_feature_branch() {
    current_branch=$(git branch --show-current)
    if [[ ! $current_branch =~ ^[0-9]+- ]]; then
        log_error "Not on a feature branch. Current branch: $current_branch"
        log_error "Feature branches should be named like: 002-feature-name"
        exit 1
    fi
    log_info "On feature branch: $current_branch"
}

# Check for uncommitted changes
check_clean_working_dir() {
    if [[ -n $(git status --porcelain) ]]; then
        log_warn "Working directory is not clean. Stashing changes..."
        git stash push -m "Stash before specification notification"
        STASHED=true
    else
        STASHED=false
    fi
}

# Find the latest specification directory
find_spec_dir() {
    # Look for directories matching pattern [0-9]*
    latest_spec=$(find "$SPEC_DIR" -maxdepth 1 -type d -name "[0-9]*" | sort -V | tail -1)

    if [[ -z "$latest_spec" ]]; then
        log_error "No specification directory found in $SPEC_DIR"
        exit 1
    fi

    log_info "Found specification directory: $latest_spec"
    echo "$latest_spec"
}

# Update README.md with new specifications
update_readme() {
    local spec_dir=$1
    local spec_name=$(basename "$spec_dir")
    local spec_display_name=$(echo "$spec_name" | sed 's/^0*//' | sed 's/-/ /g' | sed 's/\b\w/\u&/g')

    log_info "Updating README.md with $spec_display_name specifications..."

    # Check if README already has specs section
    if grep -q "## ðŸ“š Documentation" README.md; then
        # Find the specs section and add our new spec
        awk -v spec_name="$spec_display_name" -v spec_path="$spec_dir" '
        /## ðŸ“š Documentation/ {
            print
            print "- **" spec_name " Specifications**: [View Details](" spec_path "/README.md)"
            next
        }
        { print }
        ' README.md > README.tmp && mv README.tmp README.md
    else
        # Add specs section after the ðŸ“š Documentation line
        sed -i "/## ðŸ“š Documentation/a\\n- **$spec_display_name Specifications**: [View Details]($spec_dir/README.md)" README.md
    fi
}

# Update ANTIGRAVITY.md with specification details
update_antigravity() {
    local spec_dir=$1
    local spec_name=$(basename "$spec_dir")

    log_info "Updating ANTIGRAVITY.md with specification reference..."

    # Add specification reference to ANTIGRAVITY.md
    cat >> .agent/ANTIGRAVITY.md << EOF

## Specification References

### $spec_name
- **Location**: $spec_dir/
- **Status**: Newly generated by Spec-kit
- **Purpose**: Provides detailed requirements and implementation plan

Refer to the specification files for detailed technical requirements and implementation guidance.
EOF
}

# Update CLAUDE.md with specification reference
update_claude() {
    local spec_dir=$1
    local spec_name=$(basename "$spec_dir")

    log_info "Updating CLAUDE.md with specification reference..."

    # Add specification reference to CLAUDE.md
    cat >> CLAUDE.md << EOF

## Specification References

### $spec_name
- **Specification Location**: $spec_dir/
- **Status**: Newly generated by Spec-kit
- **Implementation Priority**: Review specification documents before implementation
- **Key Files**:
  - $spec_dir/spec.md - Feature specification
  - $spec_dir/plan.md - Implementation plan
  - $spec_dir/tasks.md - Task breakdown

Follow the established workflow:
1. Review all specification documents thoroughly
2. Create implementation plan based on tasks.md
3. Execute tasks with explicit user permission
4. Verify against acceptance criteria
EOF
}

# Commit and push changes
commit_and_push() {
    log_info "Committing and pushing documentation updates..."

    git add README.md .agent/ANTIGRAVITY.md CLAUDE.md

    # Check if there are actual changes to commit
    if [[ -n $(git diff --staged) ]]; then
        git commit -m "$(cat <<'EOF'
docs: Add new specification references

- Update documentation with new specification from Spec-kit
- Follow established documentation synchronization process
- Add references to latest feature specifications

ðŸ¤– Generated with Antigravity
EOF
)"

        git push origin $(git branch --show-current)
        log_info "Changes committed and pushed successfully"
    else
        log_info "No changes to commit"
    fi
}

# Main workflow
main() {
    log_info "Starting specification notification process..."

    # Check preconditions
    check_feature_branch
    check_clean_working_dir

    # Find specification directory
    spec_dir=$(find_spec_dir)

    # Update documentation
    update_readme "$spec_dir"
    update_antigravity "$spec_dir"
    update_claude "$spec_dir"

    # Commit and push
    commit_and_push

    # Restore stashed changes if any
    if [[ "$STASHED" == true ]]; then
        log_info "Restoring stashed changes..."
        git stash pop
    fi

    log_info "Specification notification process completed!"
    log_info ""
    log_info "Next steps:"
    log_info "1. Review the created pull request"
    log_info "2. Wait for approval to merge"
    log_info "3. Switch to the feature branch for implementation"
    log_info "4. Run 'make impl' to start implementation"
}

# Run main function
main "$@"